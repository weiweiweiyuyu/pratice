# 自我介绍

## 自我介绍：

​	面试官，您好！我叫段薇羽。我的专业是数据科学与大数据技术，在学校我主要利用课外时间学习了H5、CSS、JS以及Vue、uni-app等前端框架。也接触过Python、Java等后端语言。
​	在校期间我参与过三个项目的开发，其中有党建活动通知小程序，老享乐社区活动小程序以及灵鹿聘招聘平台。在这三个项目里我担任前端开发，应用的框架主要为Vue和uni-app,目前项目都已上线并稳定运行。
​	在滴滴实习期间，快速的掌握了Mpx开发小程序，然后实现了滴滴代驾小程序的模拟开发，并且接触了埋点来达到对用户行为进行监控，同时也学习了抓包方法和流程图的构建，也着重熟悉了一下公司的开发流程以及上线流程。实习期间修复了滴滴代驾、新桔代驾、以及商务代驾项目的一些bug并实现上线。
​	业余时间里，我喜欢通过博客，整理分享自己所学的知识，简历里也有我的博客链接。在生活中，我是一个积极乐观的人，一般会通过打球的方式来放松。在校期间还曾担任过实验室的班主任以及院里的女篮队长。希望能够加入贵公司，从事前端开发这个工作！谢谢！
​	灵鹿聘：
​	https://www.smartdeer.co/#/  

​	滴滴代驾demo

​	https://github.com/weiweiweiyuyu/substitute-driving

## 为什么选择了前端开发?

自己很喜欢做前端，因为前端做出来的东西可以马上展现出来，可以给我带来最直接的成就感，不像后端做的大部分都是数据层面的东西，不能让自己马上看到。而且这两年前端技术发展很快，功能越来越强大，所以做的时间越久，感觉可挖掘的点很多，很有意思。
现在的前端开发早已不是早年的切图、特效实现和视觉表现，更多的是作为一个在整个项目产品开发团队中离用户最近的一个岗位，我觉得应该不仅仅限于实现纯传统前端的功能，更需要明白客户的需求并且在这个基础上统筹好前端和后端的一个良好耦合，从而确保前端功能的准确无误。

## 面试谈到薪资：

实习：按照公司规定来就可以（实习的话主要也是锻炼自己，不断成长的。）

校招：

1. 我对薪资不是很有概念（我目前不是很关注薪资多少），现在到北京来，比较关注成长机会（对我有挑战的东西就是有成长的）

## 英文自我介绍

### V1.0

生活篇

​	Hello interviewer, My name is Duan Weiyu. I am very happy to be shortlisted to attend this interview.
​	I am 20 years old.I was born and raised in a county in Xinxiang,Henan province.  I study in Henan University of Science and Technology. 
  In spare time,I enjoy reading books,listening to music and playing basketball.Playing basketball can make me relax and happy. Kobe Bryant is my favorite NBA star.
​	That`s all.Thank you for giving me such a valuable opportunity !

# 职业规划

## v1.0

**提升竞争力**

- 提升技术硬实力
    - 在公司里面，向周围优秀的同事学习，提高自己的技术水平，不断学习成长为一个可以独当一面的技术大牛。
    - 丰富自己的技术深度和广度。
    - 加强对所在公司业务方向的理解和研究
        - 对一些常见的业务场景有较深的理解和实践
        - 理解需求多数业务的整个大方向和思路，建立起对业务的全局观，能够根据现有需求去推测未来可能会发生的技术变更。
    - 具体规划体现在
        - 深入一些技术原理
        - 能够解决越来越复杂的问题

- 提升软实力
    - 坚持将工作和生活中的一些知识、思考和理解沉淀下来，积极分享，帮助团队和自己快速成长。
    - 新技术、新的解决方法的尝试和探索，同时产生一些技术成果或业务成果，做出一些有创新的东西（比如一些公司业务优化、方案重构、开源项目）
    - 同时就是学习产品和设计思想，用户体验方面的一些知识

# 你有什么要问我的？

## 一面二面：

1、部门主要是负责什么业务的？

2、部门的技术栈主要是什么？

3、如果可以，我想知道，面试官对我本次面试有什么评价或是建议么？

4、如果我有幸入职了，可能会负责哪块工作，主要做什么？

## hr面：

1、除了薪水外其他福利待遇有哪些？

# 项目介绍

## 介绍项目的开发环境、测试环境、生产环境

1、开发环境：开发环境是程序员们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。通俗地讲，项目尚且在编码阶段，我们的代码一般在开发环境中，不会在生产环境中。
2、测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。通常指项目测试，修改bug阶段。
3、生产环境：是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。可以理解为包含所有的功能的环境，任何项目所使用的环境都以这个为基础，然后根据客户的个性化需求来做调整或者修改。通俗地讲，项目数据前端后台已经跑通，部署在服务器上之后，有客户使用，访问，就是网站正式运行了。
一般项目流程为开发环境——测试环境——生产环境

# 灵鹿聘

## 项目介绍

该商业项目由2021年末开发，灵鹿聘是Wework（中国）旗下⼀个专注于全球招聘及相关服务的人力资源平台，旨在为大学生提供应聘的在线渠道以及为公司提供招聘的渠道，为学生创造更多样化的就业机会。
该项目共有PC端、手机H5端以及微信小程序三个端。 

## 参与情况

1、负责前端学生版的PC端、手机H5端，微信小程序三端的登录、滑块验证，注册、重置密码以及个人中心页面，个人信息的修改，附件简历以及头像上传。 
2、负责小程序在线简历的添加，删除以及编辑。

## 遇到了什么困难？怎么解决的

### 三端的登录

首先登录是分为**手机验证码登录**，**账号密码登录**，以及**小程序的一键登录**。

- 手机验证码登录

首先用户通过选择框选择区号，默认是大陆+86，然后输入手机号，输入后会进行一个对应区号的`正则判断`，手机号格式正确然后点击`获取验证码`，接着就会出现`滑块验证`，然后我们把用户滑动的坐标传给后端进行判断，滑块验证成功后，会判断这个用户`是否是新用户`，如果是则提醒先去注册，如果不是会调用发送验证码的接口，`发送验证码`。此时当判断用户手机号和验证码都以输入以后，点击登录，进行`登录的判断`，判断该用户输入的验证码是否正确，正确则登录成功，否则登录失败。

- 账号密码登录

账号密码登录是直接输入账号密码，密码则通过使用JSEncrypt进行加密，然后调用接口进行判断。

以上两种登录在成功后，会设置Cookie，将用户的用户名、token、和头像地址存到cookie里面。

- 小程序的一键登录

微信登录：首先我们需要在页面初始化的时候调用wx.login,拿到success成功后的临时登录凭证code ，然后需要将`button`组件`open-type`的值设置为 `getPhoneNumber`，当用户点击并同意之后，可以通过@getphonenumber 事件回调获取动态信息，比如`e.detail.encryptedData`(用户信息的加密数据) 和 `e.detail.iv`(加密算法的初始向量)，然后我们再紧接着调用`wx.request` 接口，设置url接口地址，然后将`code、encryptedData、iv`封装成对象传入接口，success成功后将后端返回`用户名、token、头像地址`,最后存入`Storage`里面。

**我们为什么要在请求头中的Authorization字段中设置token？而不是自动携带cookie去请求？**
首先：
**a、cookie不支持跨域**
**b、**cookie是在客户端请求时自动传给服务器的，这样会存在一个**CSRF安全问题**，当我们在请求过的A页面点击一个恶意的连接，我们的cookie就会被带着去请求，但是如果我们在请求头中设置Authorization字段，因为这个设置是需要前端手动去设置的，后端也需要进行配置，（我们后端是通过判断Authorization字段来看是否有权限的）这时候我们如果只是传了cookie,后端读到Authorization字段是空的，就会返回401。

**c、**相对安全的传输就是https。

### 滑块验证 **(手机端进行改写)**

> `@touchstart` 事件是手指开始触摸元素
> `@touchmove.stop.prevent` 手指触摸元素后移动
> `@touchend` 	事件是手指结束触摸元素

然后我们这里会涉及到一个**滑动穿透**问题，使用是uni-app uni-app提供的事件可以直接绑定事件修饰符进行修改，
给@touchmove加上  .stop 阻止冒泡行为，不让当前元素的时间继续往外触发。 .prevent 是阻止事件本身的行为。
所以我们可以给@touchmove加上  .stop  .prevent 禁止滑动穿透。当然我们也可以使用原生的监听事件addEventListener来监听移动时候的事件，然后阻止默认行为。

### 小程序的分包

（分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。）

uni-app 可以直接在pages.json中使用subPackages来进行分包，**subPackages**节点接收一个数组，数组每一项都是应用的子包，其属性值如下：

![image-20220711141440195](D:\A学习笔记\image-20220711141440195.png)

root属性为子包的根目录，pages属性为一个数组，数组元素为对象，包括页面的路径path以及style

```js
"subPackages": [
	{
		"root": "pages/jobs-package",
		"pages": [
			{
				"path": "activity-details/activity-details",
				"style": {
					"navigationBarTitleText": "活动详情",
					"enablePullDownRefresh": false
				}
			},
            {
                "path": "company-page/company-page",
                "style": {
                    "navigationBarTitleText": "公司主页",
                    "enablePullDownRefresh": false
                }

            },
		]
	}
]
```

小程序进行分包的好处：

- 可以优化小程序首次启动下载时，不分包的话整个项目体积过大，影响小程序首次启动的下载时间。
- 再多团队共同开发时可以更好的解耦协作
- 在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，会把对应分包自动下载下来，下载完成后再进行展示，此时终端界面会有等待提示。
- 微信小程序每个分包的大小是2M,总体积一共不能超过20M,字节小程序每个分包的大小是2M,总体积一共不能超过16M。

**分包后项目的构成：**

分包后，小程序项目由 1 个主包 + 多个分包组成：
主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源
分包：只包含和当前分包有关的页面和私有资源

![image-20220711141927406](D:\A学习笔记\image-20220711141927406.png)

以上就是分了三个子包。

### 小程序的preloadRule分包预载配置

配置preloadRule后，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度preloadRule 中，key 是页面路径，value 是进入此页面的预下载配置，每个配置有以下几项：

![image-20220711143233209](D:\A学习笔记\image-20220711143233209.png)

```js
{
	"pages": [{
		"path": "pages/index/index",
		"style": { ...}
	}, {
		"path": "pages/login/login",
		"style": { ...}
	}],
	//分包
	"subPackages": [{
		"root": "pagesA",
		"pages": [{
			"path": "list/list",
			"style": { ...}
		}]
	}, {
		"root": "pagesB",
		"pages": [{
			"path": "detail/detail",
			"style": { ...}
		}]
	}],
	//分包预载配置
	"preloadRule": {
		"pagesA/list/list": {
			"network": "all",
			"packages": ["__APP__"]
		},
		"pagesB/detail/detail": {
			"network": "all",
			"packages": ["pagesA"]
		}
	}

```

### 在线简历模块使用colorUI实现时间轴

这个算是一个样式上的小难点吧，就是在实现在线简历模块的教育、工作、项目经历的时候会有一个时间轴线，然后经过一系列的调研，使用了colorUI的一个时间轴组件，但是就是这个组件统一的时间轴都是一样大小的，我们的时间轴是自定义的icon图标，上面没有线段，最后一个模块的元素时间轴短，然后当时就通过设置了一个和背景同色调的色块来隐藏上方的多余的线段，然后下边距设置padding-bottom为0，就可以实现下方的缩短。

然后 就是因为我们做了国际化，所以在展示英文的时候也会出现样式的问题，需要协调中文下和英文下的布局和谐。

## 项目亮点

### 条件编译

条件编译（使用uni-app的条件编译实现多端适配 ）

条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。
条件编译是利用注释实现的，在不同语法里注释写法不一样，js使用 // 注释、css 使用 /* 注释 */、vue/nvue 模板里使用 <!-- 注释 -->；
比如pages.json 的条件编译
不同平台下的特有功能，以及**小程序平台的分包**，都可以通过 pages.json 的条件编译来更好地实现。这样，就不会在其它平台产生多余的资源，进而减小包体积。

### 国际化

使用vue-i18n实现国际化，进行语言的国际化切换

```js
//main.js
//首先安装 npm install vue-i18n 然后进行配置
import VueI18n from 'vue-i18n'
Vue.use(VueI18n)

import {
	getLang
} from "utils/cookies.js"
import Lang from 'utils/lang/index.js'

let i18nConfig = {
	locale: getLang() || 'zh-TW', // 默认使用中文, 设置语言
	messages: Lang //语言包
}
new Vue({
    el: '#app',
    ...
    i18n
})

// 通过设置 locale 来切换语言
this.$i18n.locale = cn | us

//我们项目的语言包是utils/lang/index.js中进行管理的代码如下
//utils/lang/index.js
import en_US from './en-US.js'  //英文字段对应的js文件
import zh_CN from './zh-CN.js'  //简体中文对应的js文件
import zh_TW from './zh-TW.js'  //繁体中文对应的js文件

export default {
	'en-US': {
		lang: {
			...en_US
		}
	},
	'zh-CN': {
		lang: {
			...zh_CN
		}
	},
	'zh-TW': {
		lang: {
			...zh_TW
		}
	}
}
//然后在用到的页面使用
{{$t('name')}}
```

## 项目其他知识点

### 密码加密（使用JSEncrypt）

JSEncrypt 一个基于RSA加解密的js库。RSA 是典型的**非对称加密算法**，主要具有数字签名和验签的功能。

* `公钥加密，私钥解密`
* 数字签名（俗称加签验签）：私钥加签、公钥验签。

**使用过程**

1、安装

```js
npm install jsencrypt
```

2、引用

```js
import JSEncrypt from 'jsencrypt'
```

3、**公钥加密**

```js
const publicKey = 'MIGfMA0GCSqGSIb3DQEB......'; //设置公钥
//因为我们全局要引用这个js文件的encrypt函数，所以我们要export导出方法
export function encrypt(txt) {
	var encryptor = new JSEncrypt();  // 创建加密对象实例
	encryptor.setPublicKey(publicKey);  //设置公钥
	return encryptor.encrypt(txt); // 对需要加密的数据进行加密
}
```

4、**私钥解密**

```js
const privateKey = '';
export function decrypt(txt){
	var encryptor = new JSEncrypt();
	encryptor.setPrivateKey(privateKey);
	return encryptor.decrypt(txt);
}
```

在我们需要进行加密的地方 

```js
import { encrypt } from '@/utils/rsaEncrypt'
encrypt(this.ruleForm.password)
```

补充：**MD5和RSA是网络传输中最常用的两个算法**，对比学习一下：
MD5(信息-摘要算法)，对称加密，单向加密，双方共用一个密钥，不可逆，可以对密码进行加密，只需要和数据库中的文件对比是否一样就可以判断密码是否正确。
RSA(非对称加密算法)，非对称加密算法，可逆，公钥加密，私钥解密

### 文件上传

1、form表单，经典的form和input上传

action属性为后端的上传接口，然后我们在进行文件上传的时候我们需要设置form表单的enctype(加密类型)为“multipart/form-data”

```html
<form action="http://localhost:8080/upload" method="post" enctype="multipart/form-data">
    <input type="file" name="file" id="mfile3">
    <button type="submit">上传</button>
</form>
```

2、formData

**`FormData`** 接口提供了一种表示表单数据的键值对 `key/value` 的构造方式，并且可以轻松的将数据通过`XMLHttpRequest.send()`方法发送出去，本接口和此方法都相当简单直接

使用FormData步骤如下：

1. 新建一个form实例：`new FormData();`
2. 将需要传递传递的文件加入到form中：`form.append('file', file);`
3. 发送Ajax请求

```html
<input type="file" name="" id="mfile">
<button id='btn'>上传</button>
```

```js
const mfile = document.querySelector('#mfile');
const btn = document.querySelector('#btn')
const form = new FormData();  //1、新建一个form实例
const url = 'http://localhost:8080/upload';

btn.addEventListener('click', upload)

async function upload() {
    const file = mfile.files[0];
    form.append('file', file);  //2、将需要传递传递的文件加入到form中：form.append('file', file);
    uploadAjaxApi()
    // const result = await uploadAxiosApi(url, form)
}

// 发送请求
function uploadAjaxApi() {
    //原生Ajax
    const xhr = new XMLHttpRequest();
    xhr.open('POST', url);
    xhr.onload = function () {
        console.log(xhr.responseText)
    }
    xhr.send(form)
}

async function uploadAxiosApi(url, prams) {
    //基于axios
    return await axios.post(url, prams)
}

```

同时我们还可以在使用的时候添加进度条

进度条可以通过XMLHttpRequest.upload下的onprogress方法监听上传进度，e.loaded, e.total分别表示已上传的文件大小和总文件大小

3、我们可以使用组件封装好的方法

可以使用uni-app提供的上传文件方法：**uni.chooseFile + uni.uploadFile**

uni.chooseFile():  选择文件
success表示选择文件成功后的操作 res代表拿到文件的对象，可以拿到filePath以及fileName
![在这里插入图片描述](https://img-blog.csdnimg.cn/1d022c470815488db13fff5e41958bc6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16)
uni.uploadFile(): 上传文件
![在这里插入图片描述](https://img-blog.csdnimg.cn/24678a9d91fa4860aec42818018c02f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16)

### 图片上传

**1、input选择图片**+**formData.append()上传**

input 在对图片进行选择的时候我们可以通过accept属性来进行过滤

```html
<!--过滤掉非图片格式 只支持image类型 -->
<input type="file" accept="image/*"> 
<!--更准确过滤文件格式 -->
<input type="file" accept="image/jpg, image/jpeg, image/png">
<!-- 或者 -->
<input type="file" accept=".jpg, .jpeg, .png">
```

**2、uni.chooseImage + uni.uploadFile**

uni.chooseImage：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/fd134a0e1d3b4804919c899794682865.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16)
**uni.uploadFile：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2ebd090bd10a40549e39fe90b6927256.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16)

## 大文件上传和断点续传

**大文件上传：**
● 前端上传大文件时使用`Blob.prototype.slice`将文件切片，`并发`上传多个切片，由于是并发，`切片`传输到服务端的`顺序可能会发生变化`，所以我们还需要给每个切片`记录顺序`，最后发送一个合并的请求（ Promise.all ），通知服务器合并切片。
（在生成文件切片时，需要给每个切片一个标识作为 hash，这里用到另一个库 spark-md5，它可以根据文件内容计算出文件的 hash 值，这样后端可以知道当前切片是第几个切片，用于之后的合并切片）
● 服务端接收切片并存储，收到合并请求后使用流将切片合并并到最终文件。
● 原生XMLhttpRequest的 upload.onprogress 对切片上传进度的监听。
● 使用Vue计算属性根据每个切片的进度算出整个文件的上传进度。
**断点续传：**
断点续传的原理在于 前端/服务端 需要记住已上传的切片，这样下次上传到就可以跳过之前已上传的部分，有两种方案实现记忆的功能：
● 前端使用 localStorage 记录已上传的切片hash。
● 服务端保存已上传的切片hash,前端每次上传前想服务端获取已上传的切片。
前端做处理会存在一个缺陷：如果换了浏览器就失去了记忆的效果，所以我们推荐服务端做处理。
最终处理：
● 使用spark-md5根据文件内容算出文件的hash标识
● 通过hash可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）
● 通过 XMLHttpRequest的abort方法暂停切片的上传
● 上传前返回已经上传的切片名，前端跳过这些切片的上传。

### 详细过程

首先我们要知道文件从前端上传到后端是通过二进制流。
下面是两个本地上传文件选择时展示的对象，我们可以看到File对象的更深一层原型是Blob,blob存储着大量的二进制数据，并且blob的size和type属性，都会被File对象所继承。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b521654dadd2451c937272745657f304.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/718a1f1a896d434e8440931b14951045.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16)
前端大文件上传的核心是利用Blob.prototype.slice方法，和数组的slice方法相似，调用slice方法可以返回原文件的某个切片。
这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助http的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间。

### 请求逻辑

另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序
考虑到通用性，这里没有用第三方的请求库，而是用原生XMLHttpRequest做一层简单的封装来发请求

```js
request({
      url,
      method = "post",
      data,
      headers = {},
      requestList
    }) {
      return new Promise(resolve => {
        const xhr = new XMLHttpRequest();
        xhr.open(method, url);
        Object.keys(headers).forEach(key =>
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data);
        xhr.onload = e => {
          resolve({
            data: e.target.response
          });
        };
      });
    }
```

### 上传切片

接着实现比较重要的上传功能，上传需要做两件事
● 对文件进行切片
● 将切片传输给服务端

```js
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <el-button @click="handleUpload">上传</el-button>
  </div>
</template>

<script>
+ const SIZE = 10 * 1024 * 1024; // 切片大小

export default {
  data: () => ({
    container: {
      file: null
    }，
+   data: []
  }),
  methods: {
    request() {},
    handleFileChange() {},
+    // 生成文件切片
+    createFileChunk(file, size = SIZE) {
+     const fileChunkList = [];
+      let cur = 0;
+      while (cur < file.size) {
+        fileChunkList.push({ file: file.slice(cur, cur + size) });
+        cur += size;
+      }
+      return fileChunkList;
+    },
+   // 上传切片
+    async uploadChunks() {
+      const requestList = this.data
+        .map(({ chunk，hash }) => {
+          const formData = new FormData();
+          formData.append("chunk", chunk);
+          formData.append("hash", hash);
+          formData.append("filename", this.container.file.name);
+          return { formData };
+        })
+        .map(async ({ formData }) =>
+          this.request({
+            url: "http://localhost:3000",
+            data: formData
+          })
+        );
+      await Promise.all(requestList); // 并发切片
+    },
+    async handleUpload() {
+      if (!this.container.file) return;
+      const fileChunkList = this.createFileChunk(this.container.file);
+      this.data = fileChunkList.map(({ file }，index) => ({
+        chunk: file,
+        //需要给每个切片一个标识作为 hash，这里暂时使用文件名 + 下标，
+        //这样后端可以知道当前切片是第几个切片，用于之后的合并切片
+        hash: this.container.file.name + "-" + index // 文件名 + 数组下标
+      }));
+      await this.uploadChunks();
+    }
  }
};
</script>
```

当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片
createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中返回
在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名 + 下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片
随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 request 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片.
发送合并请求
这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片

```
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <el-button @click="handleUpload">上传</el-button>
  </div>
</template>

<script>
export default {
  data: () => ({
    container: {
      file: null
    },
    data: []
  }),
  methods: {
    request() {},
    handleFileChange() {},
    createFileChunk() {},
    // 上传切片，同时过滤已上传的切片
    async uploadChunks() {
      const requestList = this.data
        .map(({ chunk，hash }) => {
          const formData = new FormData();
          formData.append("chunk", chunk);
          formData.append("hash", hash);
          formData.append("filename", this.container.file.name);
          return { formData };
        })
        .map(async ({ formData }) =>
          this.request({
            url: "http://localhost:3000",
            data: formData
          })
        );
      await Promise.all(requestList);
+      // 合并切片
+     await this.mergeRequest();
    },
+    async mergeRequest() {
+      await this.request({
+        url: "http://localhost:3000/merge",
+        headers: {
+          "content-type": "application/json"
+        },
+        data: JSON.stringify({
+          filename: this.container.file.name
+        })
+      });
+    },    
    async handleUpload() {}
  }
};
</script>
```

### 断点续传

断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传到就可以跳过之前已上传的部分，有两种方案实现记忆的功能：
● 前端使用 localStorage 记录已上传的切片hash。
● 服务端保存已上传的切片hash,前端每次上传前想服务端获取已上传的切片。
前端做处理会存在一个缺陷：如果换了浏览器就失去了记忆的效果，所以我们推荐服务端做处理。

### 生成 hash

无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash，所以我们修改一下 hash 的生成规则
这里用到另一个库 spark-md5，它可以根据文件内容计算出文件的 hash 值，另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会引起 UI 的阻塞，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互
由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了importScripts 函数用于导入外部脚本，通过它导入 spark-md5。

```js
// /public/hash.js
self.importScripts("/spark-md5.min.js"); // 导入脚本

// 生成文件 hash
self.onmessage = e => {
  const { fileChunkList } = e.data;
  const spark = new self.SparkMD5.ArrayBuffer();
  let percentage = 0;
  let count = 0;
  const loadNext = index => {
    const reader = new FileReader();
    reader.readAsArrayBuffer(fileChunkList[index].file);
    reader.onload = e => {
      count++;
      spark.append(e.target.result);
      if (count === fileChunkList.length) {
        self.postMessage({
          percentage: 100,
          hash: spark.end()
        });
        self.close();
      } else {
        percentage += 100 / fileChunkList.length;
        self.postMessage({
          percentage
        });
        // 递归计算下一个切片
        loadNext(count);
      }
    };
  };
  loadNext(0);
};
```

### 文件秒传

在实现断点续传前先简单介绍一下文件秒传
所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功
文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可

```js﻿
+    async verifyUpload(filename, fileHash) {
﻿
+       const { data } = await this.request({
﻿
+         url: "http://localhost:3000/verify",
﻿
+         headers: {
﻿
+           "content-type": "application/json"
﻿
+         },
﻿
+         data: JSON.stringify({
﻿
+           filename,
﻿
+           fileHash
﻿
+         })
﻿
+       });
﻿
+       return JSON.parse(data);
﻿
+     },
﻿
   async handleUpload() {
﻿
      if (!this.container.file) return;
﻿
      const fileChunkList = this.createFileChunk(this.container.file);
﻿
      this.container.hash = await this.calculateHash(fileChunkList);
﻿
+     const { shouldUpload } = await this.verifyUpload(
﻿
+       this.container.file.name,
﻿
+       this.container.hash
﻿
+     );
﻿
+     if (!shouldUpload) {
﻿
+       this.$message.success("秒传：上传成功");
﻿
+       return;
﻿
+    }
﻿
     this.data = fileChunkList.map(({ file }, index) => ({
﻿
        fileHash: this.container.hash,
﻿
        index,
﻿
        hash: this.container.hash + "-" + index,
﻿
        chunk: file,
﻿
        percentage: 0
﻿
      }));
﻿
      await this.uploadChunks();
﻿
    }   
```

### 暂停上传

讲完了生成 hash 和文件秒传，回到断点续传
断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传
原理是使用 XMLHttpRequest 的 abort 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法。

```js
   request({
      url,
      method = "post",
      data,
      headers = {},
      onProgress = e => e,
+     requestList
    }) {
      return new Promise(resolve => {
        const xhr = new XMLHttpRequest();
        xhr.upload.onprogress = onProgress;
        xhr.open(method, url);
        Object.keys(headers).forEach(key =>
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data);
        xhr.onload = e => {
+          // 将请求成功的 xhr 从列表中删除
+          if (requestList) {
+            const xhrIndex = requestList.findIndex(item => item === xhr);
+            requestList.splice(xhrIndex, 1);
+          }
          resolve({
            data: e.target.response
          });
        };
+        // 暴露当前 xhr 给外部
+        requestList?.push(xhr);
      });
    },
```

这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了
每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存正在上传切片的 xhr
之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片

```js
 handlePause() {
    this.requestList.forEach(xhr => xhr?.abort());
    this.requestList = [];
}
```

### 实现小程序的列表页

**列表页面**
一些小细节：有一个常见的业务场景，那就是列表页面，列表页面虽然看似简单，但是却包含着很多细节
例如：`下拉刷新、上滑加载、触底加载、没有更多内容的提示、关键字搜索、标签栏匹配，空白页面、列表项组件`。
uni-app 的列表可以使用 **scroll-view** 
使用竖向滚动时，需要给 <scroll-view> 一个固定高度，通过 css 设置 height；使用横向滚动时，需要给<scroll-view>添加`white-space: nowrap;`样式。

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/30a8842e8dd243b088b8c17eb0d895dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5a6H5a6Z5a-56KeG,size_20,color_FFFFFF,t_70,g_se,x_16) scroll-view 不适合放长列表，有性能问题。长列表滚动和下拉刷新，应该使用原生导航栏搭配页面级的滚动和下拉刷新实现。包括在app-nvue页面，长列表应该使用list而不是scroll-view。

### Vuex共享状态管理

有五种，分别是 State、 Getter、Mutation 、Action、 Module
1、state => 基本数据(数据源存放地)
2、getters => 从基本数据派生出来的数据
3、mutations => 提交更改数据的方法，同步
4、actions => 像一个装饰器，包裹mutations，使之可以异步。
5、modules => 模块化Vuex

1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。
2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

# 滴滴代驾

## 项目介绍

该项目是使用滴滴开源的小程序框架Mpx对滴滴代驾进行的一个仿照开发，通过实际项目更加熟 

练掌握了Mpx技术。 

## 参与情况

1、实现滴滴代驾首页，地址选择页，会员页面以及最后的预估价格页面包括微信小程序中的map地图组件。

2、对发单整个流程以流程图展示出来，从而实现了所有页面的简单埋点，包括曝光以及点击的埋点。

3、在学习埋点过程中对已上线的微信独立版主页优惠券弹窗的曝光量低进行分析，重新进行埋点并上线。

4、使用swiper 轮播图组件,flex布局快速搭建页面。

## **应用技术**

Mpx、微信小程序开发规范、Shell基本命令编写

## 遇到了什么难点？

也算是实习时候的难点

１、在埋点的时候要先进行对发单整个流程的一个分析，进而以流程图的形式来展示。我当时是拿到线上滴滴代驾小程序的一个测试账号，然后自己对多种情况进行一个测试发单以及发单成功或失败的流程进行了一个分析，最后将整个流程和需要埋点的地方整合为一张流程图的形式展现了。

２、首先就是在修复bug的时候需要先去读懂别人的代码逻辑以及组件之间的调用，然后刚开始感觉有点慢，之后就是自己想着用流程图来展示其中的一些关系、逻辑、以及变量的使用。慢慢画画流程图，就发现组件之间的关系以及代码之间的逻辑就很清楚的展示在眼前了。

３、就是在修改商务代驾的时候，遇到一个问题：因为商务代驾的弹框是从滴滴APP首页的弹框进去的，所以以这种路径进去的时候我们需要调用集团的接口来获取定位以及城市信息，进而进行不同城市商务代驾的展示，因为集团的接口本地无法在测试运行的时候调用，所以需要测试那边配合，每次发布一个预发布的版本然后我们进行测试，我觉得这里就会有一个效率问题。

### 实习总结

1、熟练掌握了Mpx开发小程序。

2、对一些流程能更加生动的通过流程图的形式展示。

3、更加熟悉gitFlow的整个流程，以及上线流程。

4、分析问题的时候能够很快的找到切入点，并合理的做出修改方案。

# 老享乐

## 项目简介

该商业项目由2021年下半年开发，旨在为北京某区提供一款方便老年人通过小程序报名参加一些老年课程以及活动，参与的同时拥有积分奖励功能，可用于兑换商城中商品。

## 参与情况

1、负责小程序的一键登录功能 

2、负责前端活动列表页面展示，活动详情的展示以及活动报名 

3、负责商城首页的分类以及商品的展示，商品的搜索筛选 

4、负责个人中心信息的展示功能 

## 应用技术

uni-app、Vue.js、Element UI组件库，Axios、微信小程序开发规范 

## 遇到了什么难点？

- 小程序的一键登录

微信登录：首先我们需要在页面初始化的时候调用wx.login,拿到success成功后的临时登录凭证code ，然后需要将`button`组件`open-type`的值设置为 `getPhoneNumber`，当用户点击并同意之后，可以通过@getphonenumber 事件回调获取动态信息，比如`e.detail.encryptedData`(用户信息的加密数据) 和 `e.detail.iv`(加密算法的初始向量)，然后我们再紧接着调用`wx.request` 接口，设置url接口地址，然后将`code、encryptedData、iv`封装成对象传入接口，success成功后将后端返回`用户名、token、头像地址`,最后存入`Storage`里面。

